<!DOCTYPE html><html lang="en" class="__variable_188709 __variable_f05b2e"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/370fbeb3d5d383fc-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/4cf2300e9c8272f7-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/images/sky/hero.jpg"/><link rel="preload" as="image" href="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/logo.jpg"/><link rel="preload" as="image" href="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic01.png"/><link rel="preload" as="image" href="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic02.png"/><link rel="preload" as="image" href="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic03.png"/><link rel="preload" as="image" href="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic04.png"/><link rel="preload" as="image" href="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic05.png"/><link rel="preload" as="image" href="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic06.png"/><link rel="preload" as="image" href="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic07.png"/><link rel="stylesheet" href="/_next/static/css/a973827d94e4dac5.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/ebe6fbbe99646c97.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/598b09e17ec3b27b.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-06e7e4f151d607cb.js"/><script src="/_next/static/chunks/4bd1b696-d4d5eb693d0a7af9.js" async=""></script><script src="/_next/static/chunks/684-156f158a5850de9d.js" async=""></script><script src="/_next/static/chunks/main-app-5e733401fc257057.js" async=""></script><script src="/_next/static/chunks/874-1d5071fab5c23a5a.js" async=""></script><script src="/_next/static/chunks/63-b8ef6e972851fb15.js" async=""></script><script src="/_next/static/chunks/app/layout-66f854c5f608570d.js" async=""></script><script src="/_next/static/chunks/598-889c1586942b7842.js" async=""></script><script src="/_next/static/chunks/app/page-c42db5e253cc6e8c.js" async=""></script><meta name="next-size-adjust" content=""/><title>Andy Golubev | Cloud Architect &amp; DevOps Engineer</title><meta name="description" content="Personal website of AWS &amp; GCP certified Cloud Architect &amp; DevOps Engineer Andy Golubev. Certifications, GitHub work, and articles on Kubernetes and Terraform."/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="48x48"/><link rel="icon" href="/icon.png?a0799f5d3aa48e9f" type="image/png" sizes="512x512"/><link rel="apple-touch-icon" href="/apple-icon.png?21c489252a03a1cc" type="image/png" sizes="180x180"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><header class="Header_header__AF_3G"><div class="Header_rect__bQjpJ"></div><nav class="Header_nav__LVYU2"><a href="/">Home</a><a href="mailto:andygolubevcontact@gmail.com" target="_blank">Contact</a><a href="/articles/">Articles</a><a href="https://github.com/andygolubev" target="_blank">GitHub</a><a href="https://www.linkedin.com/in/andy-golubev/" target="_blank">LinkedIn</a></nav></header><div class="page_articleContainer__6YqF2"><h1 style="font-size:2rem">Terraform and DigitalOcean: Automating Infrastructure and Catching the Hidden Load Balancer</h1>
<p><strong>Date: 17 May 2023</strong></p>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/logo.jpg" alt="logo"/></figure>
<h2>Introduction:</h2>
<p>In this article, I will demonstrate the process of provisioning various components of infrastructure, including Projects, Virtual Private Clouds (VPCs), Kubernetes clusters, Load Balancers, and DNS Records. Additionally, I will outline the steps to configure Kubernetes with ingress and cert-manager, all within a single pipeline.</p>
<p>For this purpose, I have chosen DigitalOcean as the cloud provider due to its cost-effectiveness in comparison to leading providers like AWS, GCP, and Azure. To facilitate the infrastructure provisioning, I will be utilizing Terraform, a powerful infrastructure as code tool. Unfortunately, I won&#x27;t be able to incorporate Terragrunt into this setup, as I encountered difficulties in configuring it with DigitalOcean Bucket (Space).</p>
<h2>Project structure:</h2>
<p>The core of my project involves defining a live infrastructure along with several modules. The infrastructure definition comprises two distinct stages, which can be visualized through the provided diagram.
You can find all of my code in my GitHub repository: <a href="https://github.com/andygolubev/terraform-digital-ocean">https://github.com/andygolubev/terraform-digital-ocean</a></p>
<p>Initially, I attempted to handle both stages within a single script. However, during the implementation, I encountered a limitation with Terraform. Specifically, I discovered that Terraform&#x27;s integration with the DigitalOcean provider did not allow for the creation and configuration of Kubernetes using the HashiCorp Kubernetes provider within the same script.</p>
<p>To address this challenge and ensure a smooth deployment process, I decided to split the infrastructure definition into two stages:</p>
<p>Stage 1: Infrastructure Provisioning (VPC, Kubernetes, PostgreSQL, Install Nginx and Cert manager)
Stage 2: Kubernetes Configuration, DNS records setup</p>
<p>By separating the infrastructure provisioning and Kubernetes configuration into distinct stages, we can overcome the limitations imposed by the integration challenges mentioned earlier. This approach allows for granular control and flexibility when deploying and managing infrastructure and Kubernetes resources.</p>
<p>Furthermore, this division of stages enables better modularization and reusability, as each stage can be version-controlled, tested, and deployed independently. This not only simplifies the maintenance and troubleshooting process but also promotes scalability and agility when making changes or expanding the infrastructure in the future.</p>
<p>Overall, by navigating around the constraints and adopting a two-stage approach, we can effectively define and deploy our live infrastructure while integrating Kubernetes seamlessly into the process, ensuring a reliable and scalable environment for our applications.</p>
<p>This is my folders structure:</p>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic01.png" alt="folder structure"/></figure>
<p>By separating the infrastructure provisioning and Kubernetes configuration into distinct stages, we can overcome the limitations imposed by the integration challenges mentioned earlier. This approach allows for granular control and flexibility when deploying and managing infrastructure and Kubernetes resources.</p>
<p>Furthermore, this division of stages enables better modularization and reusability, as each stage can be version-controlled, tested, and deployed independently. This not only simplifies the maintenance and troubleshooting process but also promotes scalability and agility when making changes or expanding the infrastructure in the future.</p>
<p>Overall, by navigating around the constraints and adopting a two-stage approach, we can effectively define and deploy our live infrastructure while integrating Kubernetes seamlessly into the process, ensuring a reliable and scalable environment for our applications.</p>
<p>This is my folders structure:</p>
<pre><code>➜  terraform-digital-ocean git:(main) tree .
.
├── Infrastructure
│   └── digitalocean
│       ├── infrastructure-live
│       │   └── test-v1
│       │       ├── stage1
│       │       │   ├── main-stage1.tf
│       │       │   └── outputs.tf
│       │       └── stage2
│       │           ├── main-stage2.tf
│       │           └── outputs.tf
│       └── infrastructure-modules
│           ├── kubernetes-config
│           │   └── v1.0
│           │       ├── 0-versions.tf
│           │       ├── 1-save-kubeconfig.tf
│           │       ├── 2-cluster-issuer.tf
│           │       ├── 3-ingress-demo.tf
│           │       ├── 4-services-good-afternoon.tf
│           │       ├── 4-services-good-evening.tf
│           │       ├── 4-services-good-morning.tf
│           │       ├── 5-service-pagenotfound.tf
│           │       ├── 6-load-balancer.tf
│           │       ├── 7-records.tf
│           │       ├── 8-variables.tf
│           │       └── 9-outputs.tf
│           ├── kubernetes-provision
│           │   └── v1.0
│           │       ├── 0-versions.tf
│           │       ├── 1-kubernetes.tf
│           │       ├── 2-save-kubeconfig.tf
│           │       ├── 3-ingress-and-cert-manager.tf
│           │       ├── 4-registry-access.tf
│           │       ├── 5-variables.tf
│           │       └── 6-outputs.tf
│           ├── postgresql
│           │   └── v1.0
│           │       ├── 0-versions.tf
│           │       ├── 1-postgres.tf
│           │       ├── 2-variables.tf
│           │       └── 3-outputs.tf
│           └── vpc
│               └── v1.0
│                   ├── 0-versions.tf
│                   ├── 1-vpc.tf
│                   ├── 2-variables.tf
│                   └── 3-outputs.tf
├── LICENSE
└── README.md
</code></pre>
<h2>Terraform backend setup:</h2>
<p>Prior to executing my pipeline, I have created a private bucket in DigitalOcean for storing terraform states.</p>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic02.png" alt="terraform backend"/></figure>
<h2>Stage 1. Provision the infrastructure</h2>
<p>During this stage, I utilize my &quot;main-stage1.tf&quot; file to declare the necessary values for infrastructure provisioning. Additionally, I ensure proper management of dependencies between modules to guarantee a smooth and coherent deployment process.</p>
<pre><code>...
resource &quot;digitalocean_project&quot; &quot;this&quot; {
    name        = &quot;infra-demo-v1&quot; 
...
}

module &quot;vpc&quot; {
    source = &quot;../../../infrastructure-modules/vpc/v1.0&quot;
    vpc_name             = &quot;vpc-test&quot;
...
}

module &quot;kubernetes-provision&quot; {
    source = &quot;../../../infrastructure-modules/kubernetes-provision/v1.0&quot;
...
    k8s_cluster_name = &quot;demo-cluster-test-v1&quot; #Edit
    vpc_id = module.vpc.vpc_id

...
    k8s_embedded_pool_size = &quot;s-4vcpu-8gb&quot;
    k8s_embedded_pool_nodes_count = 1 

    # Type &quot;true&quot; if you want this pool of nodes
    pool_1_enabled = true
    k8s_pool_1_size = &quot;s-4vcpu-8gb&quot;
    k8s_pool_1_nodes_count = 1

...
    depends_on = [ module.vpc, digitalocean_project.this,]
}

module &quot;postgresql&quot; {
    source = &quot;../../../infrastructure-modules/postgresql/v1.0&quot;

...
    postgre_enabled = true
    posgre_cluster_name = &quot;postgresql-demo-test-v1&quot;
...

    depends_on = [ module.vpc, digitalocean_project.this,]
}
</code></pre>
<p>The complete content of the file: <a href="https://github.com/andygolubev/terraform-digital-ocean/blob/main/infrastructure/digitalocean/infrastructure-live/test-v1/stage1/main-stage1.tf">main-stage1.tf</a></p>
<p>The output of the Stage 1 is:</p>
<pre><code>Outputs:

k8s_cluster_id = &quot;ba4854df-c6de-4deb-8385-77014b491454&quot;
k8s_cluster_name = &quot;demo-cluster-test-v1&quot;
k8s_cluster_urn = &quot;do:kubernetes:ba4854df-c6de-4deb-8385-77014b491454&quot;
</code></pre>
<p>In my pipeline, I utilize &quot;k8s_cluster_name&quot; output as an input for Stage 2. You can find details in the pipeline listing provided at the end of this article.</p>
<h2>Stage 2. Configure the Kubernetes cluster and DNS</h2>
<p>In Stage 2 of my pipeline, I use a combination of Kubernetes manifests, local command execution, and the creation of DigitalOcean resources to achieve the desired configuration and setup. You can see it in my &quot;kubernetes-config&quot; terraform module: <a href="https://github.com/andygolubev/terraform-digital-ocean/blob/main/infrastructure/digitalocean/infrastructure-modules/kubernetes-config/v1.0/main-stage2.tf">main-stage2.tf</a></p>
<p>The &quot;main-stage2.tf&quot; file includes all the essential configurations for Stage 2.</p>
<p>The complete content of the file: <a href="https://github.com/andygolubev/terraform-digital-ocean/blob/main/Infrastructure/digitalocean/infrastructure-live/test-v1/stage2/main-stage2.tf">main-stage2.tf</a></p>
<pre><code>...
module &quot;kubernetes-config&quot; {
source = &quot;../../../infrastructure-modules/kubernetes-config/v1.0&quot;

digital_ocean_api_token_for_k8s_config = var.digital_ocean_api_token
k8s_config_cluster_name = var.k8s_cluster_name


domain = &quot;kuber.work&quot;
service1-subdomain = &quot;service-1-test-morning&quot;
service2-subdomain = &quot;service-2-test-afternoon&quot;
service3-subdomain = &quot;service-3-test-evening&quot;
lb-workaround-subdomain = &quot;lb-workaround-test&quot;
service1-service = &quot;goodmorning&quot; 
service2-service = &quot;goodafternoon&quot; 
service3-service = &quot;goodevening&quot; 
cluster-issuer = &quot;letsencrypt-prod&quot; # letsencrypt-prod or letsencrypt-staging
ssl-redirect = &quot;false&quot; # To accommodate the requirement for the service to respond on HTTP, a temporary value is assigned for certificate issuing.

}
</code></pre>
<p>To illustrate and demonstrate the functionality of the system, I have incorporated three distinct services, each offering unique endpoints:</p>
<p>https://service-1-test-morning.kuber.work
https://service-2-test-afternoon.kuber.work
https://service-3-test-evening.kuber.work</p>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic03.png" alt="resources"/></figure>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic04.png" alt="dns records"/></figure>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic05.png" alt="vpc error"/></figure>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic06.png" alt="pipeline success"/></figure>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic07.png" alt="workflows"/></figure>
<h2>Automate the process using GitHub actions</h2>
<p>For the automation I use two separate workflows:</p>
<ol>
<li>Provision the infrastructure</li>
<li>Destroy the infrastructure (Manual run)</li>
</ol>
<p>Workflow for the infrastructure provision:</p>
<pre><code>name: 1-Provision-infrastructure

on:
    push:
    branches: [ &quot;main&quot; ]
    pull_request:
    branches: [ &quot;main&quot; ]

env:
    PATH_STAGE_1: &quot;./Infrastructure/digitalocean/infrastructure-live/test-v1/stage1/&quot;
    PATH_STAGE_2: &quot;./Infrastructure/digitalocean/infrastructure-live/test-v1/stage2/&quot;

jobs:
    provision:
    name: Provision the infrastructure in Digital Ocean and configure Kubernetes
    runs-on: ubuntu-latest
    steps:
        - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
            token: ${{ secrets.DO_API_TOKEN }}

        - name: Checkout
        uses: actions/checkout@v3

        - name: Provision the infrastructure
        env:
            DO_API_TOKEN: ${{secrets.DO_API_TOKEN }}
            DO_BUCKET_ACCESS_KEY: ${{ secrets.DO_BUCKET_ACCESS_KEY }}
            DO_BUCKET_SECRET_KEY: ${{ secrets.DO_BUCKET_SECRET_KEY }}
        run: |
            terraform -chdir=$PATH_STAGE_1 init -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; -backend-config=&quot;access_key=$DO_BUCKET_ACCESS_KEY&quot; -backend-config=&quot;secret_key=$DO_BUCKET_SECRET_KEY&quot;
            terraform -chdir=$PATH_STAGE_1 plan -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot;
            terraform -chdir=$PATH_STAGE_1 apply -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; --auto-approve
            terraform -chdir=$PATH_STAGE_2 init -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; -backend-config=&quot;access_key=$DO_BUCKET_ACCESS_KEY&quot; -backend-config=&quot;secret_key=$DO_BUCKET_SECRET_KEY&quot;
            terraform -chdir=$PATH_STAGE_2 plan -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; -var=&quot;k8s_cluster_name=$(cd $PATH_STAGE_1 &amp;&amp; terraform output -raw k8s_cluster_name)&quot;
            terraform -chdir=$PATH_STAGE_2 apply -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; --auto-approve -var=&quot;k8s_cluster_name=$(cd $PATH_STAGE_1 &amp;&amp; terraform output -raw k8s_cluster_name)&quot;
</code></pre>
<p>Here I use the output of the Stage 1 as the input for the Stage 2:
<code>terraform -chdir=$PATH_STAGE_2 apply -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; --auto-approve -var=&quot;k8s_cluster_name=$(cd $PATH_STAGE_1 &amp;&amp; terraform output -raw k8s_cluster_name)&quot;</code></p>
<p>so this command returns just the cluster name:
<code>terraform output -raw k8s_cluster_name</code></p>
<p>Workflow for the infrastructure destruction:</p>
<pre><code>name: 2-Destroy-infrastructure

on:
workflow_dispatch:

env:
PATH_STAGE_1: &quot;./Infrastructure/digitalocean/infrastructure-live/test-v1/stage1/&quot;
PATH_STAGE_2: &quot;./Infrastructure/digitalocean/infrastructure-live/test-v1/stage2/&quot;

jobs:
destroy:
    name: Destroy the infrastructure in Digital Ocean
    runs-on: ubuntu-latest
    steps:
    - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
        token: ${{ secrets.DO_API_TOKEN }}

    - name: Checkout
        uses: actions/checkout@v3

    - name: Destroy the infrastructure
        env:
        DO_API_TOKEN: ${{ secrets.DO_API_TOKEN }}
        DO_BUCKET_ACCESS_KEY: ${{ secrets.DO_BUCKET_ACCESS_KEY }}
        DO_BUCKET_SECRET_KEY: ${{ secrets.DO_BUCKET_SECRET_KEY }}
        run: |
        terraform -chdir=$PATH_STAGE_1 init -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; -backend-config=&quot;access_key=$DO_BUCKET_ACCESS_KEY&quot; -backend-config=&quot;secret_key=$DO_BUCKET_SECRET_KEY&quot;
        doctl auth init --access-token $DO_API_TOKEN
        doctl kubernetes cluster kubeconfig save $(terraform -chdir=$PATH_STAGE_1  output -raw  k8s_cluster_name) || true
        terraform -chdir=$PATH_STAGE_2 init -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; -backend-config=&quot;access_key=$DO_BUCKET_ACCESS_KEY&quot; -backend-config=&quot;secret_key=$DO_BUCKET_SECRET_KEY&quot; || true
        terraform -chdir=$PATH_STAGE_2 apply -destroy -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; --auto-approve -var=&quot;k8s_cluster_name=$(cd $PATH_STAGE_1 &amp;&amp; terraform output -raw k8s_cluster_name)&quot; || true
        terraform -chdir=$PATH_STAGE_1 apply -destroy -var=&quot;digital_ocean_api_token=$DO_API_TOKEN&quot; --auto-approve
</code></pre>
<p>In this stage, I begin by destroying the resources in Stage 2, followed by the destruction of all remaining resources.</p>
<p>To enable multiple runs of my pipelines, it is crucial to include the capability to destroy Stage 1 along with the main resources.
To ignore any potential command failures before destruction of Stage 1, I use &quot;|| true&quot; expression.</p>
<p><code>terraform -chdir=$PATH_STAGE_2 apply -destroy --auto-approve || true</code></p>
<p>During my exploration, I encountered an issue with DigitalOcean regarding VPC and Project deletion. Despite not observing any associated resources in the console, DigitalOcean indicates that the VPC still possesses resources. Consequently, when attempting to remove the VPC using Terraform, it raises an error due to the inconsistency.</p>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic05.png" alt="vpc error"/></figure>
<p>When I rerun the pipeline, this specific step executes without encountering any errors.</p>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic06.png" alt="pipeline success"/></figure>
<p>If you experienced this issue, please contact me or drop a comment.</p>
<p>Below, you will find a list of pipeline workflows:</p>
<figure style="margin:2rem 0"><img src="/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic07.png" alt="workflows"/></figure>
<h2>Conclusion:</h2>
<p>In this article, I have demonstrated the process of provisioning various components of infrastructure using Terraform on DigitalOcean. By adopting a two-stage approach, I have overcome the limitations of the Terraform and the DigitalOcean providers.</p>
<p>You can find all of my code in my GitHub repository: <a href="https://github.com/andygolubev/terraform-digital-ocean">https://github.com/andygolubev/terraform-digital-ocean</a></p>
<p>Feel free to connect with me on LinkedIn: <a href="https://www.linkedin.com/in/andy-golubev/">https://www.linkedin.com/in/andy-golubev/</a></p></div><!--$--><!--/$--><!--$--><!--/$--><footer class="Footer_footer__4vzqH"><div class="Footer_footerContainer__77_mg"><div class="DisintegratingImage_container__wGJdA Footer_footerBackgroundImage__aXnu1"><img src="/images/sky/hero.jpg" alt="Footer background" class="DisintegratingImage_image__qNdyj" style="opacity:1;transition:opacity 0.5s ease-out"/></div><h2>Run in the cloud. Reach the world.</h2><div class="Footer_footerLinks__xuRtG"><a href="https://github.com/andygolubev" target="_blank"><img alt="GitHub" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" style="color:transparent" src="/images/icons/github.svg"/></a><a href="https://www.linkedin.com/in/andy-golubev/" target="_blank"><img alt="LinkedIn" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" style="color:transparent" src="/images/icons/linkedin.svg"/></a><a href="mailto:andygolubevcontact@gmail.com" target="_blank"><img alt="Send email" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" style="color:transparent" src="/images/icons/email.svg"/></a></div></div></footer><div class="Credits_credits__Spqox"><a href="https://www.linkedin.com/in/olgagolubev/" target="_blank">Developed and designed by Olga Golubev</a></div><script src="/_next/static/chunks/webpack-06e7e4f151d607cb.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[2784,[\"874\",\"static/chunks/874-1d5071fab5c23a5a.js\",\"63\",\"static/chunks/63-b8ef6e972851fb15.js\",\"177\",\"static/chunks/app/layout-66f854c5f608570d.js\"],\"default\"]\n3:I[7555,[],\"\"]\n4:I[1295,[],\"\"]\n5:I[4557,[\"874\",\"static/chunks/874-1d5071fab5c23a5a.js\",\"63\",\"static/chunks/63-b8ef6e972851fb15.js\",\"598\",\"static/chunks/598-889c1586942b7842.js\",\"974\",\"static/chunks/app/page-c42db5e253cc6e8c.js\"],\"default\"]\n6:I[3063,[\"874\",\"static/chunks/874-1d5071fab5c23a5a.js\",\"63\",\"static/chunks/63-b8ef6e972851fb15.js\",\"598\",\"static/chunks/598-889c1586942b7842.js\",\"974\",\"static/chunks/app/page-c42db5e253cc6e8c.js\"],\"Image\"]\n8:I[9665,[],\"MetadataBoundary\"]\na:I[9665,[],\"OutletBoundary\"]\nd:I[4911,[],\"AsyncMetadataOutlet\"]\nf:I[9665,[],\"ViewportBoundary\"]\n11:I[6614,[],\"\"]\n:HL[\"/_next/static/media/370fbeb3d5d383fc-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/4cf2300e9c8272f7-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/a973827d94e4dac5.css\",\"style\"]\n:HL[\"/_next/static/css/ebe6fbbe99646c97.css\",\"style\"]\n:HL[\"/_next/static/css/598b09e17ec3b27b.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"qwxATPgDXcEEwlAakW752\",\"p\":\"\",\"c\":[\"\",\"articles\",\"terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"articles\",{\"children\":[[\"slug\",\"terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/a973827d94e4dac5.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ebe6fbbe99646c97.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"__variable_188709 __variable_f05b2e\",\"children\":[\"$\",\"body\",null,{\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"footer\",null,{\"className\":\"Footer_footer__4vzqH\",\"children\":[\"$\",\"div\",null,{\"className\":\"Footer_footerContainer__77_mg\",\"children\":[[\"$\",\"$L5\",null,{\"src\":\"/images/sky/hero.jpg\",\"alt\":\"Footer background\",\"className\":\"Footer_footerBackgroundImage__aXnu1\"}],[\"$\",\"h2\",null,{\"children\":\"Run in the cloud. Reach the world.\"}],[\"$\",\"div\",null,{\"className\":\"Footer_footerLinks__xuRtG\",\"children\":[[\"$\",\"a\",null,{\"href\":\"https://github.com/andygolubev\",\"target\":\"_blank\",\"children\":[\"$\",\"$L6\",null,{\"src\":\"/images/icons/github.svg\",\"alt\":\"GitHub\",\"width\":24,\"height\":24}]}],[\"$\",\"a\",null,{\"href\":\"https://www.linkedin.com/in/andy-golubev/\",\"target\":\"_blank\",\"children\":[\"$\",\"$L6\",null,{\"src\":\"/images/icons/linkedin.svg\",\"alt\":\"LinkedIn\",\"width\":24,\"height\":24}]}],[\"$\",\"a\",null,{\"href\":\"mailto:andygolubevcontact@gmail.com\",\"target\":\"_blank\",\"children\":[\"$\",\"$L6\",null,{\"src\":\"/images/icons/email.svg\",\"alt\":\"Send email\",\"width\":24,\"height\":24}]}]]}]]}]}],[\"$\",\"div\",null,{\"className\":\"Credits_credits__Spqox\",\"children\":[\"$\",\"a\",null,{\"href\":\"https://www.linkedin.com/in/olgagolubev/\",\"target\":\"_blank\",\"children\":\"Developed and designed by Olga Golubev\"}]}]]}]}]]}],{\"children\":[\"articles\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/598b09e17ec3b27b.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"5d04DHV_eSNeqflpP-Add\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[4911,[],\"AsyncMetadata\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script><script>self.__next_f.push([1,"15:T899,"])</script><script>self.__next_f.push([1,"➜  terraform-digital-ocean git:(main) tree .\n.\n├── Infrastructure\n│   └── digitalocean\n│       ├── infrastructure-live\n│       │   └── test-v1\n│       │       ├── stage1\n│       │       │   ├── main-stage1.tf\n│       │       │   └── outputs.tf\n│       │       └── stage2\n│       │           ├── main-stage2.tf\n│       │           └── outputs.tf\n│       └── infrastructure-modules\n│           ├── kubernetes-config\n│           │   └── v1.0\n│           │       ├── 0-versions.tf\n│           │       ├── 1-save-kubeconfig.tf\n│           │       ├── 2-cluster-issuer.tf\n│           │       ├── 3-ingress-demo.tf\n│           │       ├── 4-services-good-afternoon.tf\n│           │       ├── 4-services-good-evening.tf\n│           │       ├── 4-services-good-morning.tf\n│           │       ├── 5-service-pagenotfound.tf\n│           │       ├── 6-load-balancer.tf\n│           │       ├── 7-records.tf\n│           │       ├── 8-variables.tf\n│           │       └── 9-outputs.tf\n│           ├── kubernetes-provision\n│           │   └── v1.0\n│           │       ├── 0-versions.tf\n│           │       ├── 1-kubernetes.tf\n│           │       ├── 2-save-kubeconfig.tf\n│           │       ├── 3-ingress-and-cert-manager.tf\n│           │       ├── 4-registry-access.tf\n│           │       ├── 5-variables.tf\n│           │       └── 6-outputs.tf\n│           ├── postgresql\n│           │   └── v1.0\n│           │       ├── 0-versions.tf\n│           │       ├── 1-postgres.tf\n│           │       ├── 2-variables.tf\n│           │       └── 3-outputs.tf\n│           └── vpc\n│               └── v1.0\n│                   ├── 0-versions.tf\n│                   ├── 1-vpc.tf\n│                   ├── 2-variables.tf\n│                   └── 3-outputs.tf\n├── LICENSE\n└── README.md\n"])</script><script>self.__next_f.push([1,"16:T746,name: 1-Provision-infrastructure\n\non:\n    push:\n    branches: [ \"main\" ]\n    pull_request:\n    branches: [ \"main\" ]\n\nenv:\n    PATH_STAGE_1: \"./Infrastructure/digitalocean/infrastructure-live/test-v1/stage1/\"\n    PATH_STAGE_2: \"./Infrastructure/digitalocean/infrastructure-live/test-v1/stage2/\"\n\njobs:\n    provision:\n    name: Provision the infrastructure in Digital Ocean and configure Kubernetes\n    runs-on: ubuntu-latest\n    steps:\n        - name: Install doctl\n        uses: digitalocean/action-doctl@v2\n        with:\n            token: ${{ secrets.DO_API_TOKEN }}\n\n        - name: Checkout\n        uses: actions/checkout@v3\n\n        - name: Provision the infrastructure\n        env:\n            DO_API_TOKEN: ${{secrets.DO_API_TOKEN }}\n            DO_BUCKET_ACCESS_KEY: ${{ secrets.DO_BUCKET_ACCESS_KEY }}\n            DO_BUCKET_SECRET_KEY: ${{ secrets.DO_BUCKET_SECRET_KEY }}\n        run: |\n            terraform -chdir=$PATH_STAGE_1 init -var=\"digital_ocean_api_token=$DO_API_TOKEN\" -backend-config=\"access_key=$DO_BUCKET_ACCESS_KEY\" -backend-config=\"secret_key=$DO_BUCKET_SECRET_KEY\"\n            terraform -chdir=$PATH_STAGE_1 plan -var=\"digital_ocean_api_token=$DO_API_TOKEN\"\n            terraform -chdir=$PATH_STAGE_1 apply -var=\"digital_ocean_api_token=$DO_API_TOKEN\" --auto-approve\n            terraform -chdir=$PATH_STAGE_2 init -var=\"digital_ocean_api_token=$DO_API_TOKEN\" -backend-config=\"access_key=$DO_BUCKET_ACCESS_KEY\" -backend-config=\"secret_key=$DO_BUCKET_SECRET_KEY\"\n            terraform -chdir=$PATH_STAGE_2 plan -var=\"digital_ocean_api_token=$DO_API_TOKEN\" -var=\"k8s_cluster_name=$(cd $PATH_STAGE_1 \u0026\u0026 terraform output -raw k8s_cluster_name)\"\n            terraform -chdir=$PATH_STAGE_2 apply -var=\"digital_ocean_api_token=$DO_API_TOKEN\" --auto-approve -var=\"k8s_cluster_name=$(cd $PATH_STAGE_1 \u0026\u0026 terraform output -raw k8s_cluster_name)\"\n17:T674,name: 2-Destroy-infrastructure\n\non:\nworkflow_dispatch:\n\nenv:\nPATH_STAGE_1: \"./Infrastructure/digitalocean/infrastructure-live/test-v1/stage1/\"\nPATH_STAGE_2: \"./Infrastruc"])</script><script>self.__next_f.push([1,"ture/digitalocean/infrastructure-live/test-v1/stage2/\"\n\njobs:\ndestroy:\n    name: Destroy the infrastructure in Digital Ocean\n    runs-on: ubuntu-latest\n    steps:\n    - name: Install doctl\n        uses: digitalocean/action-doctl@v2\n        with:\n        token: ${{ secrets.DO_API_TOKEN }}\n\n    - name: Checkout\n        uses: actions/checkout@v3\n\n    - name: Destroy the infrastructure\n        env:\n        DO_API_TOKEN: ${{ secrets.DO_API_TOKEN }}\n        DO_BUCKET_ACCESS_KEY: ${{ secrets.DO_BUCKET_ACCESS_KEY }}\n        DO_BUCKET_SECRET_KEY: ${{ secrets.DO_BUCKET_SECRET_KEY }}\n        run: |\n        terraform -chdir=$PATH_STAGE_1 init -var=\"digital_ocean_api_token=$DO_API_TOKEN\" -backend-config=\"access_key=$DO_BUCKET_ACCESS_KEY\" -backend-config=\"secret_key=$DO_BUCKET_SECRET_KEY\"\n        doctl auth init --access-token $DO_API_TOKEN\n        doctl kubernetes cluster kubeconfig save $(terraform -chdir=$PATH_STAGE_1  output -raw  k8s_cluster_name) || true\n        terraform -chdir=$PATH_STAGE_2 init -var=\"digital_ocean_api_token=$DO_API_TOKEN\" -backend-config=\"access_key=$DO_BUCKET_ACCESS_KEY\" -backend-config=\"secret_key=$DO_BUCKET_SECRET_KEY\" || true\n        terraform -chdir=$PATH_STAGE_2 apply -destroy -var=\"digital_ocean_api_token=$DO_API_TOKEN\" --auto-approve -var=\"k8s_cluster_name=$(cd $PATH_STAGE_1 \u0026\u0026 terraform output -raw k8s_cluster_name)\" || true\n        terraform -chdir=$PATH_STAGE_1 apply -destroy -var=\"digital_ocean_api_token=$DO_API_TOKEN\" --auto-approve\n"])</script><script>self.__next_f.push([1,"7:[\"$\",\"div\",null,{\"className\":\"page_articleContainer__6YqF2\",\"children\":[[\"$\",\"h1\",null,{\"style\":{\"fontSize\":\"2rem\"},\"children\":\"Terraform and DigitalOcean: Automating Infrastructure and Catching the Hidden Load Balancer\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"Date: 17 May 2023\"}]}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/logo.jpg\",\"alt\":\"logo\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Introduction:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In this article, I will demonstrate the process of provisioning various components of infrastructure, including Projects, Virtual Private Clouds (VPCs), Kubernetes clusters, Load Balancers, and DNS Records. Additionally, I will outline the steps to configure Kubernetes with ingress and cert-manager, all within a single pipeline.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"For this purpose, I have chosen DigitalOcean as the cloud provider due to its cost-effectiveness in comparison to leading providers like AWS, GCP, and Azure. To facilitate the infrastructure provisioning, I will be utilizing Terraform, a powerful infrastructure as code tool. Unfortunately, I won't be able to incorporate Terragrunt into this setup, as I encountered difficulties in configuring it with DigitalOcean Bucket (Space).\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Project structure:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The core of my project involves defining a live infrastructure along with several modules. The infrastructure definition comprises two distinct stages, which can be visualized through the provided diagram.\\nYou can find all of my code in my GitHub repository: \",[\"$\",\"a\",null,{\"href\":\"https://github.com/andygolubev/terraform-digital-ocean\",\"children\":\"https://github.com/andygolubev/terraform-digital-ocean\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Initially, I attempted to handle both stages within a single script. However, during the implementation, I encountered a limitation with Terraform. Specifically, I discovered that Terraform's integration with the DigitalOcean provider did not allow for the creation and configuration of Kubernetes using the HashiCorp Kubernetes provider within the same script.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To address this challenge and ensure a smooth deployment process, I decided to split the infrastructure definition into two stages:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Stage 1: Infrastructure Provisioning (VPC, Kubernetes, PostgreSQL, Install Nginx and Cert manager)\\nStage 2: Kubernetes Configuration, DNS records setup\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"By separating the infrastructure provisioning and Kubernetes configuration into distinct stages, we can overcome the limitations imposed by the integration challenges mentioned earlier. This approach allows for granular control and flexibility when deploying and managing infrastructure and Kubernetes resources.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Furthermore, this division of stages enables better modularization and reusability, as each stage can be version-controlled, tested, and deployed independently. This not only simplifies the maintenance and troubleshooting process but also promotes scalability and agility when making changes or expanding the infrastructure in the future.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Overall, by navigating around the constraints and adopting a two-stage approach, we can effectively define and deploy our live infrastructure while integrating Kubernetes seamlessly into the process, ensuring a reliable and scalable environment for our applications.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This is my folders structure:\"}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic01.png\",\"alt\":\"folder structure\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"By separating the infrastructure provisioning and Kubernetes configuration into distinct stages, we can overcome the limitations imposed by the integration challenges mentioned earlier. This approach allows for granular control and flexibility when deploying and managing infrastructure and Kubernetes resources.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Furthermore, this division of stages enables better modularization and reusability, as each stage can be version-controlled, tested, and deployed independently. This not only simplifies the maintenance and troubleshooting process but also promotes scalability and agility when making changes or expanding the infrastructure in the future.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Overall, by navigating around the constraints and adopting a two-stage approach, we can effectively define and deploy our live infrastructure while integrating Kubernetes seamlessly into the process, ensuring a reliable and scalable environment for our applications.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This is my folders structure:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"$15\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Terraform backend setup:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Prior to executing my pipeline, I have created a private bucket in DigitalOcean for storing terraform states.\"}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic02.png\",\"alt\":\"terraform backend\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Stage 1. Provision the infrastructure\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"During this stage, I utilize my \\\"main-stage1.tf\\\" file to declare the necessary values for infrastructure provisioning. Additionally, I ensure proper management of dependencies between modules to guarantee a smooth and coherent deployment process.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"...\\nresource \\\"digitalocean_project\\\" \\\"this\\\" {\\n    name        = \\\"infra-demo-v1\\\" \\n...\\n}\\n\\nmodule \\\"vpc\\\" {\\n    source = \\\"../../../infrastructure-modules/vpc/v1.0\\\"\\n    vpc_name             = \\\"vpc-test\\\"\\n...\\n}\\n\\nmodule \\\"kubernetes-provision\\\" {\\n    source = \\\"../../../infrastructure-modules/kubernetes-provision/v1.0\\\"\\n...\\n    k8s_cluster_name = \\\"demo-cluster-test-v1\\\" #Edit\\n    vpc_id = module.vpc.vpc_id\\n\\n...\\n    k8s_embedded_pool_size = \\\"s-4vcpu-8gb\\\"\\n    k8s_embedded_pool_nodes_count = 1 \\n\\n    # Type \\\"true\\\" if you want this pool of nodes\\n    pool_1_enabled = true\\n    k8s_pool_1_size = \\\"s-4vcpu-8gb\\\"\\n    k8s_pool_1_nodes_count = 1\\n\\n...\\n    depends_on = [ module.vpc, digitalocean_project.this,]\\n}\\n\\nmodule \\\"postgresql\\\" {\\n    source = \\\"../../../infrastructure-modules/postgresql/v1.0\\\"\\n\\n...\\n    postgre_enabled = true\\n    posgre_cluster_name = \\\"postgresql-demo-test-v1\\\"\\n...\\n\\n    depends_on = [ module.vpc, digitalocean_project.this,]\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The complete content of the file: \",[\"$\",\"a\",null,{\"href\":\"https://github.com/andygolubev/terraform-digital-ocean/blob/main/infrastructure/digitalocean/infrastructure-live/test-v1/stage1/main-stage1.tf\",\"children\":\"main-stage1.tf\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The output of the Stage 1 is:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"Outputs:\\n\\nk8s_cluster_id = \\\"ba4854df-c6de-4deb-8385-77014b491454\\\"\\nk8s_cluster_name = \\\"demo-cluster-test-v1\\\"\\nk8s_cluster_urn = \\\"do:kubernetes:ba4854df-c6de-4deb-8385-77014b491454\\\"\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In my pipeline, I utilize \\\"k8s_cluster_name\\\" output as an input for Stage 2. You can find details in the pipeline listing provided at the end of this article.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Stage 2. Configure the Kubernetes cluster and DNS\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In Stage 2 of my pipeline, I use a combination of Kubernetes manifests, local command execution, and the creation of DigitalOcean resources to achieve the desired configuration and setup. You can see it in my \\\"kubernetes-config\\\" terraform module: \",[\"$\",\"a\",null,{\"href\":\"https://github.com/andygolubev/terraform-digital-ocean/blob/main/infrastructure/digitalocean/infrastructure-modules/kubernetes-config/v1.0/main-stage2.tf\",\"children\":\"main-stage2.tf\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The \\\"main-stage2.tf\\\" file includes all the essential configurations for Stage 2.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The complete content of the file: \",[\"$\",\"a\",null,{\"href\":\"https://github.com/andygolubev/terraform-digital-ocean/blob/main/Infrastructure/digitalocean/infrastructure-live/test-v1/stage2/main-stage2.tf\",\"children\":\"main-stage2.tf\"}]]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"...\\nmodule \\\"kubernetes-config\\\" {\\nsource = \\\"../../../infrastructure-modules/kubernetes-config/v1.0\\\"\\n\\ndigital_ocean_api_token_for_k8s_config = var.digital_ocean_api_token\\nk8s_config_cluster_name = var.k8s_cluster_name\\n\\n\\ndomain = \\\"kuber.work\\\"\\nservice1-subdomain = \\\"service-1-test-morning\\\"\\nservice2-subdomain = \\\"service-2-test-afternoon\\\"\\nservice3-subdomain = \\\"service-3-test-evening\\\"\\nlb-workaround-subdomain = \\\"lb-workaround-test\\\"\\nservice1-service = \\\"goodmorning\\\" \\nservice2-service = \\\"goodafternoon\\\" \\nservice3-service = \\\"goodevening\\\" \\ncluster-issuer = \\\"letsencrypt-prod\\\" # letsencrypt-prod or letsencrypt-staging\\nssl-redirect = \\\"false\\\" # To accommodate the requirement for the service to respond on HTTP, a temporary value is assigned for certificate issuing.\\n\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To illustrate and demonstrate the functionality of the system, I have incorporated three distinct services, each offering unique endpoints:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"https://service-1-test-morning.kuber.work\\nhttps://service-2-test-afternoon.kuber.work\\nhttps://service-3-test-evening.kuber.work\"}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic03.png\",\"alt\":\"resources\"}]}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic04.png\",\"alt\":\"dns records\"}]}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic05.png\",\"alt\":\"vpc error\"}]}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic06.png\",\"alt\":\"pipeline success\"}]}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic07.png\",\"alt\":\"workflows\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Automate the process using GitHub actions\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"For the automation I use two separate workflows:\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Provision the infrastructure\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Destroy the infrastructure (Manual run)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Workflow for the infrastructure provision:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"$16\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Here I use the output of the Stage 1 as the input for the Stage 2:\\n\",[\"$\",\"code\",null,{\"children\":\"terraform -chdir=$PATH_STAGE_2 apply -var=\\\"digital_ocean_api_token=$DO_API_TOKEN\\\" --auto-approve -var=\\\"k8s_cluster_name=$(cd $PATH_STAGE_1 \u0026\u0026 terraform output -raw k8s_cluster_name)\\\"\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"so this command returns just the cluster name:\\n\",[\"$\",\"code\",null,{\"children\":\"terraform output -raw k8s_cluster_name\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Workflow for the infrastructure destruction:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"$17\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In this stage, I begin by destroying the resources in Stage 2, followed by the destruction of all remaining resources.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To enable multiple runs of my pipelines, it is crucial to include the capability to destroy Stage 1 along with the main resources.\\nTo ignore any potential command failures before destruction of Stage 1, I use \\\"|| true\\\" expression.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"terraform -chdir=$PATH_STAGE_2 apply -destroy --auto-approve || true\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"During my exploration, I encountered an issue with DigitalOcean regarding VPC and Project deletion. Despite not observing any associated resources in the console, DigitalOcean indicates that the VPC still possesses resources. Consequently, when attempting to remove the VPC using Terraform, it raises an error due to the inconsistency.\"}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic05.png\",\"alt\":\"vpc error\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"When I rerun the pipeline, this specific step executes without encountering any errors.\"}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic06.png\",\"alt\":\"pipeline success\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"If you experienced this issue, please contact me or drop a comment.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Below, you will find a list of pipeline workflows:\"}],\"\\n\",[\"$\",\"figure\",null,{\"style\":{\"margin\":\"2rem 0\"},\"children\":[\"$\",\"img\",null,{\"src\":\"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic07.png\",\"alt\":\"workflows\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Conclusion:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In this article, I have demonstrated the process of provisioning various components of infrastructure using Terraform on DigitalOcean. By adopting a two-stage approach, I have overcome the limitations of the Terraform and the DigitalOcean providers.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"You can find all of my code in my GitHub repository: \",[\"$\",\"a\",null,{\"href\":\"https://github.com/andygolubev/terraform-digital-ocean\",\"children\":\"https://github.com/andygolubev/terraform-digital-ocean\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Feel free to connect with me on LinkedIn: \",[\"$\",\"a\",null,{\"href\":\"https://www.linkedin.com/in/andy-golubev/\",\"children\":\"https://www.linkedin.com/in/andy-golubev/\"}]]}]]}]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Andy Golubev | Cloud Architect \u0026 DevOps Engineer\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Personal website of AWS \u0026 GCP certified Cloud Architect \u0026 DevOps Engineer Andy Golubev. Certifications, GitHub work, and articles on Kubernetes and Terraform.\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/icon.png?a0799f5d3aa48e9f\",\"type\":\"image/png\",\"sizes\":\"512x512\"}],[\"$\",\"link\",\"4\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-icon.png?21c489252a03a1cc\",\"type\":\"image/png\",\"sizes\":\"180x180\"}]],\"error\":null,\"digest\":\"$undefined\"}\ne:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>