1:"$Sreact.fragment"
2:I[2784,["874","static/chunks/874-1d5071fab5c23a5a.js","63","static/chunks/63-b8ef6e972851fb15.js","177","static/chunks/app/layout-128ffe95b5a5832b.js"],"default"]
3:I[7555,[],""]
4:I[1295,[],""]
5:I[4557,["874","static/chunks/874-1d5071fab5c23a5a.js","63","static/chunks/63-b8ef6e972851fb15.js","598","static/chunks/598-889c1586942b7842.js","974","static/chunks/app/page-c42db5e253cc6e8c.js"],"default"]
6:I[3063,["874","static/chunks/874-1d5071fab5c23a5a.js","63","static/chunks/63-b8ef6e972851fb15.js","598","static/chunks/598-889c1586942b7842.js","974","static/chunks/app/page-c42db5e253cc6e8c.js"],"Image"]
8:I[9665,[],"MetadataBoundary"]
a:I[9665,[],"OutletBoundary"]
d:I[4911,[],"AsyncMetadataOutlet"]
f:I[9665,[],"ViewportBoundary"]
11:I[6614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/6975cac0a7ae24f4-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/8f74a3e5566f948c.css","style"]
:HL["/_next/static/css/7599afaaf9c9e399.css","style"]
:HL["/_next/static/css/598b09e17ec3b27b.css","style"]
0:{"P":null,"b":"O8H6bF7pcj2mznJgXipHh","p":"","c":["","articles","terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer",""],"i":false,"f":[[["",{"children":["articles",{"children":[["slug","terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/8f74a3e5566f948c.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/7599afaaf9c9e399.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","className":"__variable_5cfdac __variable_7620cf","children":["$","body",null,{"children":[["$","$L2",null,{}],["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","footer",null,{"className":"Footer_footer__4vzqH","children":["$","div",null,{"className":"Footer_footerContainer__77_mg","children":[["$","$L5",null,{"src":"/images/sky/hero.jpg","alt":"Footer background","className":"Footer_footerBackgroundImage__aXnu1"}],["$","h2",null,{"children":"Run in the cloud. Reach the world."}],["$","div",null,{"className":"Footer_footerLinks__xuRtG","children":[["$","a",null,{"href":"https://github.com/andygolubev","target":"_blank","children":["$","$L6",null,{"src":"/images/icons/github.svg","alt":"GitHub","width":24,"height":24}]}],["$","a",null,{"href":"https://www.linkedin.com/in/andy-golubev/","target":"_blank","children":["$","$L6",null,{"src":"/images/icons/linkedin.svg","alt":"LinkedIn","width":24,"height":24}]}],["$","a",null,{"href":"mailto:andygolubevcontact@gmail.com","target":"_blank","children":["$","$L6",null,{"src":"/images/icons/email.svg","alt":"Send email","width":24,"height":24}]}]]}]]}]}],["$","div",null,{"className":"Credits_credits__Spqox","children":["$","a",null,{"href":"https://www.linkedin.com/in/olgagolubev/","target":"_blank","children":"Developed and designed by Olga Golubev"}]}]]}]}]]}],{"children":["articles",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer","d"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L7",["$","$L8",null,{"children":"$L9"}],[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/598b09e17ec3b27b.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$La",null,{"children":["$Lb","$Lc",["$","$Ld",null,{"promise":"$@e"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","fH-He6Ttby9hsw6EYUTaX",{"children":[["$","$Lf",null,{"children":"$L10"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$11","$undefined"],"s":false,"S":true}
12:"$Sreact.suspense"
13:I[4911,[],"AsyncMetadata"]
9:["$","$12",null,{"fallback":null,"children":["$","$L13",null,{"promise":"$@14"}]}]
c:null
15:T899,➜  terraform-digital-ocean git:(main) tree .
.
├── Infrastructure
│   └── digitalocean
│       ├── infrastructure-live
│       │   └── test-v1
│       │       ├── stage1
│       │       │   ├── main-stage1.tf
│       │       │   └── outputs.tf
│       │       └── stage2
│       │           ├── main-stage2.tf
│       │           └── outputs.tf
│       └── infrastructure-modules
│           ├── kubernetes-config
│           │   └── v1.0
│           │       ├── 0-versions.tf
│           │       ├── 1-save-kubeconfig.tf
│           │       ├── 2-cluster-issuer.tf
│           │       ├── 3-ingress-demo.tf
│           │       ├── 4-services-good-afternoon.tf
│           │       ├── 4-services-good-evening.tf
│           │       ├── 4-services-good-morning.tf
│           │       ├── 5-service-pagenotfound.tf
│           │       ├── 6-load-balancer.tf
│           │       ├── 7-records.tf
│           │       ├── 8-variables.tf
│           │       └── 9-outputs.tf
│           ├── kubernetes-provision
│           │   └── v1.0
│           │       ├── 0-versions.tf
│           │       ├── 1-kubernetes.tf
│           │       ├── 2-save-kubeconfig.tf
│           │       ├── 3-ingress-and-cert-manager.tf
│           │       ├── 4-registry-access.tf
│           │       ├── 5-variables.tf
│           │       └── 6-outputs.tf
│           ├── postgresql
│           │   └── v1.0
│           │       ├── 0-versions.tf
│           │       ├── 1-postgres.tf
│           │       ├── 2-variables.tf
│           │       └── 3-outputs.tf
│           └── vpc
│               └── v1.0
│                   ├── 0-versions.tf
│                   ├── 1-vpc.tf
│                   ├── 2-variables.tf
│                   └── 3-outputs.tf
├── LICENSE
└── README.md
16:T746,name: 1-Provision-infrastructure

on:
    push:
    branches: [ "main" ]
    pull_request:
    branches: [ "main" ]

env:
    PATH_STAGE_1: "./Infrastructure/digitalocean/infrastructure-live/test-v1/stage1/"
    PATH_STAGE_2: "./Infrastructure/digitalocean/infrastructure-live/test-v1/stage2/"

jobs:
    provision:
    name: Provision the infrastructure in Digital Ocean and configure Kubernetes
    runs-on: ubuntu-latest
    steps:
        - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
            token: ${{ secrets.DO_API_TOKEN }}

        - name: Checkout
        uses: actions/checkout@v3

        - name: Provision the infrastructure
        env:
            DO_API_TOKEN: ${{secrets.DO_API_TOKEN }}
            DO_BUCKET_ACCESS_KEY: ${{ secrets.DO_BUCKET_ACCESS_KEY }}
            DO_BUCKET_SECRET_KEY: ${{ secrets.DO_BUCKET_SECRET_KEY }}
        run: |
            terraform -chdir=$PATH_STAGE_1 init -var="digital_ocean_api_token=$DO_API_TOKEN" -backend-config="access_key=$DO_BUCKET_ACCESS_KEY" -backend-config="secret_key=$DO_BUCKET_SECRET_KEY"
            terraform -chdir=$PATH_STAGE_1 plan -var="digital_ocean_api_token=$DO_API_TOKEN"
            terraform -chdir=$PATH_STAGE_1 apply -var="digital_ocean_api_token=$DO_API_TOKEN" --auto-approve
            terraform -chdir=$PATH_STAGE_2 init -var="digital_ocean_api_token=$DO_API_TOKEN" -backend-config="access_key=$DO_BUCKET_ACCESS_KEY" -backend-config="secret_key=$DO_BUCKET_SECRET_KEY"
            terraform -chdir=$PATH_STAGE_2 plan -var="digital_ocean_api_token=$DO_API_TOKEN" -var="k8s_cluster_name=$(cd $PATH_STAGE_1 && terraform output -raw k8s_cluster_name)"
            terraform -chdir=$PATH_STAGE_2 apply -var="digital_ocean_api_token=$DO_API_TOKEN" --auto-approve -var="k8s_cluster_name=$(cd $PATH_STAGE_1 && terraform output -raw k8s_cluster_name)"
17:T674,name: 2-Destroy-infrastructure

on:
workflow_dispatch:

env:
PATH_STAGE_1: "./Infrastructure/digitalocean/infrastructure-live/test-v1/stage1/"
PATH_STAGE_2: "./Infrastructure/digitalocean/infrastructure-live/test-v1/stage2/"

jobs:
destroy:
    name: Destroy the infrastructure in Digital Ocean
    runs-on: ubuntu-latest
    steps:
    - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
        token: ${{ secrets.DO_API_TOKEN }}

    - name: Checkout
        uses: actions/checkout@v3

    - name: Destroy the infrastructure
        env:
        DO_API_TOKEN: ${{ secrets.DO_API_TOKEN }}
        DO_BUCKET_ACCESS_KEY: ${{ secrets.DO_BUCKET_ACCESS_KEY }}
        DO_BUCKET_SECRET_KEY: ${{ secrets.DO_BUCKET_SECRET_KEY }}
        run: |
        terraform -chdir=$PATH_STAGE_1 init -var="digital_ocean_api_token=$DO_API_TOKEN" -backend-config="access_key=$DO_BUCKET_ACCESS_KEY" -backend-config="secret_key=$DO_BUCKET_SECRET_KEY"
        doctl auth init --access-token $DO_API_TOKEN
        doctl kubernetes cluster kubeconfig save $(terraform -chdir=$PATH_STAGE_1  output -raw  k8s_cluster_name) || true
        terraform -chdir=$PATH_STAGE_2 init -var="digital_ocean_api_token=$DO_API_TOKEN" -backend-config="access_key=$DO_BUCKET_ACCESS_KEY" -backend-config="secret_key=$DO_BUCKET_SECRET_KEY" || true
        terraform -chdir=$PATH_STAGE_2 apply -destroy -var="digital_ocean_api_token=$DO_API_TOKEN" --auto-approve -var="k8s_cluster_name=$(cd $PATH_STAGE_1 && terraform output -raw k8s_cluster_name)" || true
        terraform -chdir=$PATH_STAGE_1 apply -destroy -var="digital_ocean_api_token=$DO_API_TOKEN" --auto-approve
7:["$","div",null,{"className":"page_articleContainer__6YqF2","children":[["$","h1",null,{"style":{"fontSize":"2rem"},"children":"Terraform and DigitalOcean: Automating Infrastructure and Catching the Hidden Load Balancer"}],"\n",["$","p",null,{"children":["$","strong",null,{"children":"Date: 17 May 2023"}]}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/logo.jpg","alt":"logo"}]}],"\n",["$","h2",null,{"children":"Introduction:"}],"\n",["$","p",null,{"children":"In this article, I will demonstrate the process of provisioning various components of infrastructure, including Projects, Virtual Private Clouds (VPCs), Kubernetes clusters, Load Balancers, and DNS Records. Additionally, I will outline the steps to configure Kubernetes with ingress and cert-manager, all within a single pipeline."}],"\n",["$","p",null,{"children":"For this purpose, I have chosen DigitalOcean as the cloud provider due to its cost-effectiveness in comparison to leading providers like AWS, GCP, and Azure. To facilitate the infrastructure provisioning, I will be utilizing Terraform, a powerful infrastructure as code tool. Unfortunately, I won't be able to incorporate Terragrunt into this setup, as I encountered difficulties in configuring it with DigitalOcean Bucket (Space)."}],"\n",["$","h2",null,{"children":"Project structure:"}],"\n",["$","p",null,{"children":["The core of my project involves defining a live infrastructure along with several modules. The infrastructure definition comprises two distinct stages, which can be visualized through the provided diagram.\nYou can find all of my code in my GitHub repository: ",["$","a",null,{"href":"https://github.com/andygolubev/terraform-digital-ocean","children":"https://github.com/andygolubev/terraform-digital-ocean"}]]}],"\n",["$","p",null,{"children":"Initially, I attempted to handle both stages within a single script. However, during the implementation, I encountered a limitation with Terraform. Specifically, I discovered that Terraform's integration with the DigitalOcean provider did not allow for the creation and configuration of Kubernetes using the HashiCorp Kubernetes provider within the same script."}],"\n",["$","p",null,{"children":"To address this challenge and ensure a smooth deployment process, I decided to split the infrastructure definition into two stages:"}],"\n",["$","p",null,{"children":"Stage 1: Infrastructure Provisioning (VPC, Kubernetes, PostgreSQL, Install Nginx and Cert manager)\nStage 2: Kubernetes Configuration, DNS records setup"}],"\n",["$","p",null,{"children":"By separating the infrastructure provisioning and Kubernetes configuration into distinct stages, we can overcome the limitations imposed by the integration challenges mentioned earlier. This approach allows for granular control and flexibility when deploying and managing infrastructure and Kubernetes resources."}],"\n",["$","p",null,{"children":"Furthermore, this division of stages enables better modularization and reusability, as each stage can be version-controlled, tested, and deployed independently. This not only simplifies the maintenance and troubleshooting process but also promotes scalability and agility when making changes or expanding the infrastructure in the future."}],"\n",["$","p",null,{"children":"Overall, by navigating around the constraints and adopting a two-stage approach, we can effectively define and deploy our live infrastructure while integrating Kubernetes seamlessly into the process, ensuring a reliable and scalable environment for our applications."}],"\n",["$","p",null,{"children":"This is my folders structure:"}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic01.png","alt":"folder structure"}]}],"\n",["$","p",null,{"children":"By separating the infrastructure provisioning and Kubernetes configuration into distinct stages, we can overcome the limitations imposed by the integration challenges mentioned earlier. This approach allows for granular control and flexibility when deploying and managing infrastructure and Kubernetes resources."}],"\n",["$","p",null,{"children":"Furthermore, this division of stages enables better modularization and reusability, as each stage can be version-controlled, tested, and deployed independently. This not only simplifies the maintenance and troubleshooting process but also promotes scalability and agility when making changes or expanding the infrastructure in the future."}],"\n",["$","p",null,{"children":"Overall, by navigating around the constraints and adopting a two-stage approach, we can effectively define and deploy our live infrastructure while integrating Kubernetes seamlessly into the process, ensuring a reliable and scalable environment for our applications."}],"\n",["$","p",null,{"children":"This is my folders structure:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$15"}]}],"\n",["$","h2",null,{"children":"Terraform backend setup:"}],"\n",["$","p",null,{"children":"Prior to executing my pipeline, I have created a private bucket in DigitalOcean for storing terraform states."}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic02.png","alt":"terraform backend"}]}],"\n",["$","h2",null,{"children":"Stage 1. Provision the infrastructure"}],"\n",["$","p",null,{"children":"During this stage, I utilize my \"main-stage1.tf\" file to declare the necessary values for infrastructure provisioning. Additionally, I ensure proper management of dependencies between modules to guarantee a smooth and coherent deployment process."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"...\nresource \"digitalocean_project\" \"this\" {\n    name        = \"infra-demo-v1\" \n...\n}\n\nmodule \"vpc\" {\n    source = \"../../../infrastructure-modules/vpc/v1.0\"\n    vpc_name             = \"vpc-test\"\n...\n}\n\nmodule \"kubernetes-provision\" {\n    source = \"../../../infrastructure-modules/kubernetes-provision/v1.0\"\n...\n    k8s_cluster_name = \"demo-cluster-test-v1\" #Edit\n    vpc_id = module.vpc.vpc_id\n\n...\n    k8s_embedded_pool_size = \"s-4vcpu-8gb\"\n    k8s_embedded_pool_nodes_count = 1 \n\n    # Type \"true\" if you want this pool of nodes\n    pool_1_enabled = true\n    k8s_pool_1_size = \"s-4vcpu-8gb\"\n    k8s_pool_1_nodes_count = 1\n\n...\n    depends_on = [ module.vpc, digitalocean_project.this,]\n}\n\nmodule \"postgresql\" {\n    source = \"../../../infrastructure-modules/postgresql/v1.0\"\n\n...\n    postgre_enabled = true\n    posgre_cluster_name = \"postgresql-demo-test-v1\"\n...\n\n    depends_on = [ module.vpc, digitalocean_project.this,]\n}\n"}]}],"\n",["$","p",null,{"children":["The complete content of the file: ",["$","a",null,{"href":"https://github.com/andygolubev/terraform-digital-ocean/blob/main/infrastructure/digitalocean/infrastructure-live/test-v1/stage1/main-stage1.tf","children":"main-stage1.tf"}]]}],"\n",["$","p",null,{"children":"The output of the Stage 1 is:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"Outputs:\n\nk8s_cluster_id = \"ba4854df-c6de-4deb-8385-77014b491454\"\nk8s_cluster_name = \"demo-cluster-test-v1\"\nk8s_cluster_urn = \"do:kubernetes:ba4854df-c6de-4deb-8385-77014b491454\"\n"}]}],"\n",["$","p",null,{"children":"In my pipeline, I utilize \"k8s_cluster_name\" output as an input for Stage 2. You can find details in the pipeline listing provided at the end of this article."}],"\n",["$","h2",null,{"children":"Stage 2. Configure the Kubernetes cluster and DNS"}],"\n",["$","p",null,{"children":["In Stage 2 of my pipeline, I use a combination of Kubernetes manifests, local command execution, and the creation of DigitalOcean resources to achieve the desired configuration and setup. You can see it in my \"kubernetes-config\" terraform module: ",["$","a",null,{"href":"https://github.com/andygolubev/terraform-digital-ocean/blob/main/infrastructure/digitalocean/infrastructure-modules/kubernetes-config/v1.0/main-stage2.tf","children":"main-stage2.tf"}]]}],"\n",["$","p",null,{"children":"The \"main-stage2.tf\" file includes all the essential configurations for Stage 2."}],"\n",["$","p",null,{"children":["The complete content of the file: ",["$","a",null,{"href":"https://github.com/andygolubev/terraform-digital-ocean/blob/main/Infrastructure/digitalocean/infrastructure-live/test-v1/stage2/main-stage2.tf","children":"main-stage2.tf"}]]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"...\nmodule \"kubernetes-config\" {\nsource = \"../../../infrastructure-modules/kubernetes-config/v1.0\"\n\ndigital_ocean_api_token_for_k8s_config = var.digital_ocean_api_token\nk8s_config_cluster_name = var.k8s_cluster_name\n\n\ndomain = \"kuber.work\"\nservice1-subdomain = \"service-1-test-morning\"\nservice2-subdomain = \"service-2-test-afternoon\"\nservice3-subdomain = \"service-3-test-evening\"\nlb-workaround-subdomain = \"lb-workaround-test\"\nservice1-service = \"goodmorning\" \nservice2-service = \"goodafternoon\" \nservice3-service = \"goodevening\" \ncluster-issuer = \"letsencrypt-prod\" # letsencrypt-prod or letsencrypt-staging\nssl-redirect = \"false\" # To accommodate the requirement for the service to respond on HTTP, a temporary value is assigned for certificate issuing.\n\n}\n"}]}],"\n",["$","p",null,{"children":"To illustrate and demonstrate the functionality of the system, I have incorporated three distinct services, each offering unique endpoints:"}],"\n",["$","p",null,{"children":"https://service-1-test-morning.kuber.work\nhttps://service-2-test-afternoon.kuber.work\nhttps://service-3-test-evening.kuber.work"}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic03.png","alt":"resources"}]}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic04.png","alt":"dns records"}]}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic05.png","alt":"vpc error"}]}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic06.png","alt":"pipeline success"}]}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic07.png","alt":"workflows"}]}],"\n",["$","h2",null,{"children":"Automate the process using GitHub actions"}],"\n",["$","p",null,{"children":"For the automation I use two separate workflows:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"Provision the infrastructure"}],"\n",["$","li",null,{"children":"Destroy the infrastructure (Manual run)"}],"\n"]}],"\n",["$","p",null,{"children":"Workflow for the infrastructure provision:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$16"}]}],"\n",["$","p",null,{"children":["Here I use the output of the Stage 1 as the input for the Stage 2:\n",["$","code",null,{"children":"terraform -chdir=$PATH_STAGE_2 apply -var=\"digital_ocean_api_token=$DO_API_TOKEN\" --auto-approve -var=\"k8s_cluster_name=$(cd $PATH_STAGE_1 && terraform output -raw k8s_cluster_name)\""}]]}],"\n",["$","p",null,{"children":["so this command returns just the cluster name:\n",["$","code",null,{"children":"terraform output -raw k8s_cluster_name"}]]}],"\n",["$","p",null,{"children":"Workflow for the infrastructure destruction:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$17"}]}],"\n",["$","p",null,{"children":"In this stage, I begin by destroying the resources in Stage 2, followed by the destruction of all remaining resources."}],"\n",["$","p",null,{"children":"To enable multiple runs of my pipelines, it is crucial to include the capability to destroy Stage 1 along with the main resources.\nTo ignore any potential command failures before destruction of Stage 1, I use \"|| true\" expression."}],"\n",["$","p",null,{"children":["$","code",null,{"children":"terraform -chdir=$PATH_STAGE_2 apply -destroy --auto-approve || true"}]}],"\n",["$","p",null,{"children":"During my exploration, I encountered an issue with DigitalOcean regarding VPC and Project deletion. Despite not observing any associated resources in the console, DigitalOcean indicates that the VPC still possesses resources. Consequently, when attempting to remove the VPC using Terraform, it raises an error due to the inconsistency."}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic05.png","alt":"vpc error"}]}],"\n",["$","p",null,{"children":"When I rerun the pipeline, this specific step executes without encountering any errors."}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic06.png","alt":"pipeline success"}]}],"\n",["$","p",null,{"children":"If you experienced this issue, please contact me or drop a comment."}],"\n",["$","p",null,{"children":"Below, you will find a list of pipeline workflows:"}],"\n",["$","figure",null,{"style":{"margin":"2rem 0"},"children":["$","img",null,{"src":"/articles/terraform-and-digitalocean-automating-infrastructure-and-catching-the-hidden-load-balancer/pic07.png","alt":"workflows"}]}],"\n",["$","h2",null,{"children":"Conclusion:"}],"\n",["$","p",null,{"children":"In this article, I have demonstrated the process of provisioning various components of infrastructure using Terraform on DigitalOcean. By adopting a two-stage approach, I have overcome the limitations of the Terraform and the DigitalOcean providers."}],"\n",["$","p",null,{"children":["You can find all of my code in my GitHub repository: ",["$","a",null,{"href":"https://github.com/andygolubev/terraform-digital-ocean","children":"https://github.com/andygolubev/terraform-digital-ocean"}]]}],"\n",["$","p",null,{"children":["Feel free to connect with me on LinkedIn: ",["$","a",null,{"href":"https://www.linkedin.com/in/andy-golubev/","children":"https://www.linkedin.com/in/andy-golubev/"}]]}]]}]
10:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:null
14:{"metadata":[["$","title","0",{"children":"Andy Golubev | Cloud Architect & DevOps Engineer"}],["$","meta","1",{"name":"description","content":"Personal website of AWS & GCP certified Cloud Architect & DevOps Engineer Andy Golubev. Certifications, GitHub work, and articles on Kubernetes and Terraform."}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"48x48"}],["$","link","3",{"rel":"icon","href":"/icon.png?a0799f5d3aa48e9f","type":"image/png","sizes":"512x512"}],["$","link","4",{"rel":"apple-touch-icon","href":"/apple-icon.png?21c489252a03a1cc","type":"image/png","sizes":"180x180"}]],"error":null,"digest":"$undefined"}
e:{"metadata":"$14:metadata","error":null,"digest":"$undefined"}
